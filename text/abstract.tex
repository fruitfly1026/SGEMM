\begin{abstract}
In this paper, we present a methodology to demystify GPU's microarchitecture level features and demonstrate how to use
them to tune SGEMM. The methodology relies on a reverse engineering approach to crack the GPU instruction encoding in
order to build an GPU assembler, and a profound microbenchmarking at assembly level to correlate architecture features with
performance factors.
We uncover microbenchmark features, such as  dual issue impact on float arithmetic throughput, memory load width on bandwidth, register 
bank on performance. 
Based on these features, we implement the fastest SGEMM on Kepler GPU.
The performance boost is achieved on the basis of tuning {\tt FFMA} throughput as high as
hardware peak by activating dual issue and eliminating bank conflicts, then adding other non-FFMA instructions with little
penalty by choosing proper width of global/shared load instructions, and instruction scheduling.
The optimized SGEMM achieves $3104$ Gflop/s and its efficiency is $88\%$, which is 17\% higher than CUBLAS7.0 on NVIDIA Kepler K20 GPU.
\end{abstract}

