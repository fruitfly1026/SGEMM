\section{Artifact description}

%Submission and reviewing guidelines and methodology: \\
%{\em http://cTuning.org/ae/submission-20160509.html}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Abstract}

The artifact contains three parts of our work: KeplerAs assembler, optimized SGEMM code, and reverse-engineering instruction encoding code. It can support the Algorithm $2$, $3$ and Figure $9$ in our PPoPP 2017 paper: Demystifying GPU Microarchitecture to Tune SGEMM Performance. To validate the results, run the test scripts and check the results in the according text output files.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Description}

\subsubsection{Check-list (artifact meta information)}
%{\em Fill in whatever is applicable with some informal keywords and remove the rest}

{\small
\begin{itemize}
  \item {\bf Algorithm: SGEMM algorithm, KeplerAs assembler, Solver}
  \item {\bf Program: CUDA, C/C++ code, python and assembly code}
  \item {\bf Compilation: nvcc, g++, python,perl and KeplerAs.pl(after install our assembler KeplerAs)}
  %\item {\bf Compile: }
  \item {\bf Binary: Cubin and CUDA executables}
  \item {\bf Data set: matrix random generated data, solver's input is generated by script}
  \item {\bf Run-time environment: Redhat 6, CUDA driver 7.0}
  \item {\bf Hardware: NVIDIA K20 GPU}
  %\item {\bf Run-time state: }
 % \item {\bf Execution: }
  \item {\bf Output: Runtime and functionality of assembler and solver}
  \item {\bf Experiment workflow: Git clone project; run the test scripts; observe the results}
  %\item {\bf Experiment customization: }
  \item {\bf Publicly available?: Yes }
\end{itemize}
}

\subsubsection{How delivered}

%{\em Obligatory}

\subsubsection{Hardware dependencies}
Intel Xeon CPU and NVIDIA K20 GPU
\subsubsection{Software dependencies}
Red Hat Enterprise Linux Server release 6.3 (Santiago)

CUDA driver 7.0

KeplerAs GPU assembler (Inside our codes)

Python 2.7

Perl v5.10.1

Awk 3.1.7

\subsubsection{Datasets}
Data is generated when running, so no dataset required.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Installation}
Install software listed in software dependencies section.

%{\em Obligatory}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Experiment workflow}
For the convenience of the artifact evaluation, we provide a series
of shell scripts which run the solver  we have described in Algorithm 2 and 3 of the paper and store the results in the output text files. Below are the steps to download our code, build, run the experiments, and observe the results.

Clone https://github.com/PAA-NCIC/PPoPP2017\_artifact, then follow commands below.

Install the assembler.
\begin{lstlisting} [frame=tb]
$ cd PPoPP2017_artifact/KepelerAs
$ perl Makefile.PL
$ make
$ sudo make install
\end{lstlisting}

Run SGEMM algorithm to evaluation performance.
\begin{lstlisting} [frame=tb]
$ cd SGEMM/
$ ./sgemm.sh
\end{lstlisting}

Solver is composed of opcode solver, modifier solver and operand solver. 
These results will be used to build a GPU assembler.
\begin{lstlisting} [frame=tb]
$ cd Solver/
$ ./solver.sh
\end{lstlisting}
%{\em Obligatory}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Evaluation and expected result}
%{\em Obligatory}
First, our KeplerAs GPU assembler is expected to compiler assembly code correctly to cubin which should be demonstrated by SGEMM example.
Second, Figure $9$ in our paper presented the performance of our optimized SGEMM and cuBLAS SGEMM. We expect results contain Gflop/s by running sgemm experiment. %We expected solver generate bits information about opcodes, modifiers and operands.
Third, we expect the solver to crack ISA encodings automatically, and generate opcode, operand and modifier encodings information in corresponding text files. These information can be used to build a GPU assembler.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsection{Experiment customization}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Notes}
The solver might run a little long(hours in estimation).
Opcode solver, modifier solver and operand solver runs 10 miniutes, 30 miniutes and 20 miniutes respectively on Intel(R) Xeon(R) CPU E5-2670. 

