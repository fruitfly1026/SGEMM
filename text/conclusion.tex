\section{Conclusion}
\label{sec:conclusion}
We have presented a profound microbenchmarking at assembly level to demystify the architecture features under the hood, such as dual issue impact on float arithmetic throughput, memory load width on bandwidth, register bank distribution on performance etc. These parameters are worthwhile for both hardware and software researcher to understand how GK110 is designed and how to adapt program to Kepler GPU hardware.
Based on these disclosed information, we implemented the fastest SGEMM on Kepler GK110 GPU. The optimized SGEMM is $3104$ Gflop/s and efficiency is $3104/3520=88\%$, CUBLAS's SGEMM achieves $2509$ Gflp/s($71\%$ efficiency). Our optimized one is $17\%$ higher than Cublas. The performance boost is achieved on the basis of tuning {\tt FFMA} throughput as high as hardware peak, then add other non-FFMA instruction with little penalty. These optimizations include register bank conflict eliminating, {\tt FFMA} dual issue scheduling, choosing proper width of global load and shared memory load instructions and so on.
As far as we know, our assembler which will be public in future is the first assembler for Kepler GK110 architecture. In this paper, we also provided a detailed description of how we cracked the instruction encoding by presenting our decoding solver. This solver is not limited to Kepler GPU, it can be used to crack the future GPU encoding automatically. Our assembler and decoding solver open a door to optimize Nvidia GPU code in native machine level.
